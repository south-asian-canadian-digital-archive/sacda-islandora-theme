import type { Plugin } from 'vite';
import { readdirSync, statSync, readFileSync, writeFileSync, copyFileSync, existsSync } from 'fs';
import { resolve, join } from 'path';

export function drupalSdcGenerator(options: { src: string }): Plugin {
	let outDir = '';

	return {
		name: 'drupal-sdc-generator',
		configResolved(config) {
			outDir = config.build.outDir;
		},
		closeBundle() {
			const srcPath = resolve(options.src);
			// Ensure we are reading the same src directory
			if (!existsSync(srcPath)) return;

			const items = readdirSync(srcPath);

			for (const item of items) {
				const componentSrcDir = join(srcPath, item);

				// Skip files, only process directories
				if (!statSync(componentSrcDir).isDirectory()) continue;

				// Check if it's a component (has main.ts)
				// Adjust this check if your criteria for "component directory" differs
				if (!existsSync(join(componentSrcDir, 'main.ts'))) continue;

				// Target directory in dist
				const componentOutputDir = join(outDir, item);

				// Ensure output dir exists (it should if build worked, but for safety)
				if (!existsSync(componentOutputDir)) {
					// If build didn't create it, we probably shouldn't either, 
					// but let's be safe. If main.ts existed, vite should have built it.
					continue;
				}

				// 1. Process .component.yml
				const ymlFileName = `${item}.component.yml`;
				const srcYmlPath = join(componentSrcDir, ymlFileName);
				const distYmlPath = join(componentOutputDir, ymlFileName);

				if (existsSync(srcYmlPath)) {
					copyFileSync(srcYmlPath, distYmlPath);
					console.log(`[drupal-sdc] Copied ${ymlFileName}`);
				} else {
					// Scan output directory for .js and .css files generated by Vite
					const outputFiles = readdirSync(componentOutputDir);
					const jsFiles = outputFiles.filter((f) => f.endsWith('.js'));
					const cssFiles = outputFiles.filter((f) => f.endsWith('.css'));

					let jsSection = '';
					if (jsFiles.length > 0) {
						jsSection = 'library:\n  js:\n';
						jsFiles.forEach((f) => {
							jsSection += `    ${f}: { attributes: { defer: true } }\n`;
						});
					}

					let cssSection = '';
					if (cssFiles.length > 0) {
						if (!jsSection) jsSection = 'library:\n'; // Ensure library key exists if no JS
						cssSection = '  css:\n    component:\n';
						cssFiles.forEach((f) => {
							cssSection += `      ${f}: {}\n`;
						});
					}

					const defaultYml = `$schema: https://git.drupalcode.org/project/drupal/-/raw/10.1.x/core/modules/sdc/src/metadata.schema.json
name: ${item.charAt(0).toUpperCase() + item.slice(1)}
status: experimental
group: custom
${jsSection}${cssSection}`;
					writeFileSync(distYmlPath, defaultYml);
					console.log(`[drupal-sdc] Generated ${ymlFileName}`);
				}

				// 2. Process .twig
				const twigFileName = `${item}.twig`;
				const srcTwigPath = join(componentSrcDir, twigFileName);
				const distTwigPath = join(componentOutputDir, twigFileName);

				if (existsSync(srcTwigPath)) {
					copyFileSync(srcTwigPath, distTwigPath);
					console.log(`[drupal-sdc] Copied ${twigFileName}`);
				} else {
					// Find svelte file to extract tag
					const svelteFile = join(componentSrcDir, `${item}.svelte`); // Assumes naming convention
					let tagName = 'div'; // Default
					if (existsSync(svelteFile)) {
						const content = readFileSync(svelteFile, 'utf-8');
						const match = content.match(/<svelte:options\s+customElement="([^"]+)"/);
						if (match && match[1]) {
							tagName = match[1];
						}
					}

					const defaultTwig = `<${tagName} />`;
					writeFileSync(distTwigPath, defaultTwig);
					console.log(`[drupal-sdc] Generated ${twigFileName}`);
				}
			}
		}
	}
}
